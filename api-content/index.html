{"posts":[{"title":"题解 Luogu 2673","content":"这题和《具体数学》习题 6.43 相同。 众所周知 Fibonacci 数列的生成函数 F(x)=∑i≥1xiFi=x1−x−x2F(x)=\\sum\\limits_{i\\ge1}x^iF_i=\\dfrac{x}{1-x-x^2} F(x)=i≥1∑​xiFi​=1−x−x2x​ 这容易验证。考察 (1−x−x2)F(x)(1-x-x^2)F(x)(1−x−x2)F(x)，根据 Fibonacci 数列的递推式，它等于 xxx。 于是，本题所要求的式子 lim⁡K→∞∑i=1KFi10K−i=F(110)\\lim\\limits_{K\\to\\infty}\\sum\\limits_{i=1}^KF_i10^{K-i}=F\\left(\\dfrac{1}{10}\\right) K→∞lim​i=1∑K​Fi​10K−i=F(101​) 等于 1089\\dfrac{10}{89}8910​。 用这样一份代码便可以检测这个分数的循环节为 444444。打表即可。 ","link":"https://553032651yyj.github.io/post/ti-jie-luogu-2673/"},{"title":"题解 SPOJ 106","content":"贺一发计数组合学。该书提及 {nk}≡(n−⌊k2⌋−1n−1)( mod 2)\\begin{Bmatrix}n\\\\k\\end{Bmatrix}\\equiv \\dbinom{n-\\lfloor\\frac k2\\rfloor -1}{n-1}(\\bmod 2) {nk​}≡(n−1n−⌊2k​⌋−1​)(mod2) 证明考虑一列斯特林数的生成函数。 计算考虑 Lucas 定理。因为可以直接套板子，所以不放了。 或者考虑 (nm)\\dbinom{n}{m}(mn​) 的奇偶性，存在显然的结论。 ","link":"https://553032651yyj.github.io/post/ti-jie-sp106/"},{"title":"拉格朗日乘数法 及 例题","content":" 方法介绍 拉格朗日乘数法一般用于求最值。 基本形式就是，已知条件 f(x1,x2,⋯ ,xn)=kf(x_1,x_2,\\cdots,x_n)=kf(x1​,x2​,⋯,xn​)=k，求 g(x1,x2,⋯ ,xn)g(x_1,x_2,\\cdots,x_n)g(x1​,x2​,⋯,xn​) 的极值。 这时我们在 g(x1,x2,⋯ ,xn)g(x_1,x_2,\\cdots,x_n)g(x1​,x2​,⋯,xn​) 上加一个 λ(f(x1,x2,⋯ ,xn)−k)\\lambda(f(x_1,x_2,\\cdots,x_n)-k)λ(f(x1​,x2​,⋯,xn​)−k)。由于 f(x1,x2,⋯ ,xn)−k=0f(x_1,x_2,\\cdots,x_n)-k=0f(x1​,x2​,⋯,xn​)−k=0，事实上是不影响的。 接下来分别对 x1,x2,⋯ ,xn,λx_1,x_2,\\cdots,x_n,\\lambdax1​,x2​,⋯,xn​,λ 求偏导数，解一个方程组即可。 这样就成功的把限制条件搞到了代求式中。 当然这种方法比较暴力，所以一般情况下我们会选择技巧性更强的方法。 例 1 已知 x,y,z∈Rx,y,z\\in\\mathbb Rx,y,z∈R 满足 x+2y+z=1x+2y+z=1x+2y+z=1，求 xy+yz+zxxy+yz+zxxy+yz+zx 的最大值。 我们设 λ∈R\\lambda\\in\\mathbb Rλ∈R，且 F=xy+yz+zxF=xy+yz+zxF=xy+yz+zx。 显然 F=xy+yz+zx+λ(x+2y+z−1)F=xy+yz+zx+\\lambda(x+2y+z-1) F=xy+yz+zx+λ(x+2y+z−1) 那么 {Fx′=y+z+λ=0Fy′=x+z+2λ=0Fz′=x+y+λ=0Fλ′=x+2y+z−1=0\\begin{cases}F_x^\\prime=y+z+\\lambda=0\\\\F_y^\\prime=x+z+2\\lambda=0\\\\F_z^\\prime=x+y+\\lambda=0\\\\F_\\lambda^\\prime=x+2y+z-1=0\\end{cases} ⎩⎪⎪⎪⎨⎪⎪⎪⎧​Fx′​=y+z+λ=0Fy′​=x+z+2λ=0Fz′​=x+y+λ=0Fλ′​=x+2y+z−1=0​ 于是 {x=12y=0z=12λ=−12\\begin{cases}x=\\dfrac12\\\\y=0\\\\z=\\dfrac12\\\\\\lambda=-\\dfrac12\\end{cases} ⎩⎪⎪⎪⎪⎪⎪⎨⎪⎪⎪⎪⎪⎪⎧​x=21​y=0z=21​λ=−21​​ 所以 Fmax⁡=14F_{\\max}=\\dfrac14Fmax​=41​。 例 2 已知 x,y∈Rx,y\\in\\mathbb Rx,y∈R 满足 x2+y2=1x^2+y^2=1x2+y2=1，求 xyxyxy 的最值。 注意这里没有说明最值的类型，所以最值可能包含了最大值和最小值。 我们设 λ∈R\\lambda\\in\\mathbb Rλ∈R，且 F=xyF=xyF=xy。 显然 F=xy+λ(x2+y2−1)F=xy+\\lambda(x^2+y^2-1) F=xy+λ(x2+y2−1) 那么 {Fx′=y+2λx=0Fy′=x+2λy=0Fλ′=x2+y2−1=0\\begin{cases}F_x^\\prime=y+2\\lambda x=0\\\\F_y^\\prime=x+2\\lambda y=0\\\\F_\\lambda^\\prime=x^2+y^2-1=0\\end{cases} ⎩⎪⎨⎪⎧​Fx′​=y+2λx=0Fy′​=x+2λy=0Fλ′​=x2+y2−1=0​ 于是 {x=22y=−22λ=12or⁡{x=−22y=22λ=12or⁡{x=22y=22λ=−12or⁡{x=−22y=−22λ=−12\\begin{cases}x=\\dfrac{\\sqrt2}{2}\\\\y=-\\dfrac{\\sqrt2}{2}\\\\\\lambda=\\dfrac12\\end{cases}\\operatorname{or} \\begin{cases}x=-\\dfrac{\\sqrt2}{2}\\\\y=\\dfrac{\\sqrt2}{2}\\\\\\lambda=\\dfrac12\\end{cases}\\operatorname{or} \\begin{cases}x=\\dfrac{\\sqrt2}{2}\\\\y=\\dfrac{\\sqrt2}{2}\\\\\\lambda=-\\dfrac12\\end{cases}\\operatorname{or} \\begin{cases}x=-\\dfrac{\\sqrt2}{2}\\\\y=-\\dfrac{\\sqrt2}{2}\\\\\\lambda=-\\dfrac12\\end{cases} ⎩⎪⎪⎪⎪⎪⎨⎪⎪⎪⎪⎪⎧​x=22​​y=−22​​λ=21​​or⎩⎪⎪⎪⎪⎪⎨⎪⎪⎪⎪⎪⎧​x=−22​​y=22​​λ=21​​or⎩⎪⎪⎪⎪⎪⎨⎪⎪⎪⎪⎪⎧​x=22​​y=22​​λ=−21​​or⎩⎪⎪⎪⎪⎪⎨⎪⎪⎪⎪⎪⎧​x=−22​​y=−22​​λ=−21​​ 所以 Fmax⁡=12,Fmin⁡=−12F_{\\max}=\\dfrac12,F_{\\min}=-\\dfrac12Fmax​=21​,Fmin​=−21​。 例 3 已知 x,y,z∈Rx,y,z\\in\\mathbb Rx,y,z∈R 满足 x+y+z=1,x+2y−z=0x+y+z=1,x+2y-z=0x+y+z=1,x+2y−z=0，求 2xy−3y−z2xy-3y-z2xy−3y−z 的最值。 我们对原方法转换一下。 设 λ,μ∈R\\lambda,\\mu\\in\\mathbb Rλ,μ∈R，且 F=2xy−3y−zF=2xy-3y-zF=2xy−3y−z。 显然 F=2xy−3y−z+λ(x+y+z−1)+μ(x+2y−z)F=2xy-3y-z+\\lambda(x+y+z-1)+\\mu(x+2y-z) F=2xy−3y−z+λ(x+y+z−1)+μ(x+2y−z) 所以 {Fx′=2y+λ+μ=0Fy′=−3x+λ+2μ=0Fz′=−1+λ−μ=0Fλ′=x+y+z−1=0Fμ′=x+2y−z=0\\begin{cases}F_x^\\prime=2y+\\lambda+\\mu=0\\\\F_y^\\prime=-3x+\\lambda+2\\mu=0\\\\F_z^\\prime=-1+\\lambda-\\mu=0\\\\F_\\lambda^\\prime =x+y+z-1=0\\\\F_\\mu^\\prime =x+2y-z=0\\end{cases} ⎩⎪⎪⎪⎪⎪⎪⎨⎪⎪⎪⎪⎪⎪⎧​Fx′​=2y+λ+μ=0Fy′​=−3x+λ+2μ=0Fz′​=−1+λ−μ=0Fλ′​=x+y+z−1=0Fμ′​=x+2y−z=0​ 于是 {x=−76y=−1z=196λ=12μ=−12\\begin{cases}x=-\\dfrac{7}{6}\\\\y=-1\\\\z=\\dfrac{19}6\\\\\\lambda=\\dfrac12\\\\\\mu=-\\dfrac12\\end{cases} ⎩⎪⎪⎪⎪⎪⎪⎪⎪⎪⎨⎪⎪⎪⎪⎪⎪⎪⎪⎪⎧​x=−67​y=−1z=619​λ=21​μ=−21​​ 所以 Fmax⁡=1F_{\\max}=1Fmax​=1，不存在最小值。 ","link":"https://553032651yyj.github.io/post/Lagrange-multiplier-methods/"},{"title":"二次剩余学习笔记","content":" 二次剩余 | Quadratic Residue 求解方程 x2≡a( mod p)x^2\\equiv a(\\bmod p)x2≡a(modp)。 如果该方程有正整数解，称 aaa 是 ppp 的二次剩余。以下设 ppp 是及素数。 解的数量 有正整数解的 aaa 有 p−12\\dfrac{p-1}{2}2p−1​ 个。这里的 a∈[1,p−1]a\\in[1,p-1]a∈[1,p−1]。 勒让德符号 | Legendre Symbol (np)={0,n∣p−1,n∤p,∄x∈Z,x2≡n( mod p)1,n∤p,∃x∈Z,x2≡n( mod p)\\left(\\dfrac{n}{p}\\right)=\\begin{cases}0, &amp;n \\mid p\\\\-1, &amp;n\\nmid p, \\nexists x\\in \\mathbb Z, x^2\\equiv n(\\bmod p)\\\\1, &amp;n\\nmid p, \\exists x\\in \\mathbb Z, x^2\\equiv n(\\bmod p)\\end{cases} (pn​)=⎩⎪⎨⎪⎧​0,−1,1,​n∣pn∤p,∄x∈Z,x2≡n(modp)n∤p,∃x∈Z,x2≡n(modp)​ 欧拉准则 (np)=1 ⟺ np−12≡1( mod p)\\left(\\dfrac{n}{p}\\right)=1 \\iff n^{\\frac{p-1}{2}}\\equiv 1(\\bmod p) (pn​)=1⟺n2p−1​≡1(modp) 欧拉准则的证明 根据费马定理知 np−1≡1( mod p)n^{p-1}\\equiv 1(\\bmod p)np−1≡1(modp)。 那么显然 np−12≡±1( mod p)n^\\frac{p-1}{2}\\equiv \\pm1(\\bmod p)n2p−1​≡±1(modp)。因为把 111 移过去，因式分解可知。 假设存在 x2≡n( mod p)x^2\\equiv n(\\bmod p)x2≡n(modp)。那么 np−12≡xp−1≡1( mod p)n^\\frac{p-1}{2}\\equiv x^{p-1}\\equiv 1(\\bmod p)n2p−1​≡xp−1≡1(modp)，根据定义 (np)=1\\left(\\dfrac{n}{p}\\right)=1(pn​)=1。 证毕。 Cipolla 算法 找到一个 aaa 使得 (a2−np)=−1\\left(\\dfrac{a^2-n}{p}\\right)=-1(pa2−n​)=−1。 定义 i2=a2−n( mod p)i^2=a^2-n(\\bmod p)i2=a2−n(modp)，则 (a+i)p+12(a+i)^{\\frac{p+1}{2}}(a+i)2p+1​ 即为答案。 证明 x≡(a+i)p+12≡((a+i)p+1)12≡((a+i)p(a+i))12( mod p)x\\equiv (a+i)^\\frac{p+1}2\\equiv ((a+i)^{p+1})^\\frac12\\equiv ((a+i)^p(a+i))^\\frac12(\\bmod p)x≡(a+i)2p+1​≡((a+i)p+1)21​≡((a+i)p(a+i))21​(modp)。 注意到 (a+i)p≡ap+ip(a+i)^p\\equiv a^p+i^p(a+i)p≡ap+ip，原因是用二项式定理展开，除了 apa^pap 和 ipi^pip 两项，其余都存在因子 ppp。 然后呢根据费马定理的推论，ap≡a( mod p)a^p\\equiv a(\\bmod p)ap≡a(modp)，并且我们求出了 ip≡(a2−p)p−12⋅i=−1⋅i=( mod p)i^p\\equiv (a^2-p)^\\frac{p-1}{2}\\cdot i=-1\\cdot i=(\\bmod p)ip≡(a2−p)2p−1​⋅i=−1⋅i=(modp)，所以 x≡[(a−i)(a+i)]12≡(a2−i2)12≡(a2−(a2−n))12≡n12( mod p)x\\equiv [(a-i)(a+i)]^\\frac{1}{2}\\equiv (a^2-i^2)^\\frac{1}{2}\\equiv(a^2-(a^2-n))^\\frac{1}{2}\\equiv n^\\frac{1}{2}(\\bmod p)x≡[(a−i)(a+i)]21​≡(a2−i2)21​≡(a2−(a2−n))21​≡n21​(modp)。 证毕。 ​ 实现 #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; ll i2, n, p; struct Complex{ ll r, i; Complex(ll r = 0, ll i = 0): r(r), i(i) {} }; Complex operator * (Complex x, Complex y){ Complex ans = Complex(0, 0); ans.r = (x.r * y.r % p + x.i * y.i % p * i2 % p + p) % p, ans.i = (x.r * y.i % p + x.i * y.r % p + p) % p; return ans; } ll qpow(Complex a, ll b, ll p){ Complex ans = Complex(1, 0); while(b){if(b &amp; 1) ans = ans * a; a = a * a, b &gt;&gt;= 1; } return ans.r % p; } ll qpow(ll a, ll b, ll p){ a %= p; ll ans = 1; while(b){if(b &amp; 1) ans = ans * a % p; a = a * a % p, b &gt;&gt;= 1; } return ans; } inline ll rnd(){ return 1ll * rand() * rand() % p; } ll Cipolla(ll n, ll p){ assert(p % 2); if(n != 0 &amp;&amp; qpow(n, (p - 1) &gt;&gt; 1, p) == (p - 1)) return -1; ll x = 0; do x = rnd(); while(qpow(i2 = (x * x - n + p) % p, (p - 1) &gt;&gt; 1, p) != (p - 1)); return (qpow((Complex){x, 1}, (p + 1) &gt;&gt; 1, p) + p) % p; } int T; int main(){ srand(54255 * 355 + 292); cin &gt;&gt; T; while(T--){ cin &gt;&gt; n &gt;&gt; p; if(n == 0){cout &lt;&lt; 0; continue;} ll ans = Cipolla(n, p), ans2 = p - ans; if(ans == -1) {cout &lt;&lt; -1 &lt;&lt; endl; continue; } else{ cout &lt;&lt; 1 &lt;&lt; ' '; if(ans &gt; ans2) cout &lt;&lt; ans2 &lt;&lt; ' ' &lt;&lt; ans &lt;&lt; endl; else cout &lt;&lt; ans &lt;&lt; ' ' &lt;&lt; ans2 &lt;&lt; endl; } } } ","link":"https://553032651yyj.github.io/post/quad-residue/"},{"title":"个人介绍","content":"个人介绍 访客您好！我是 zj 省 wz 市的一名半退役 OIer。 常用昵称有 cvyl30, Nueliare, Hirosiny。 我的 npy 是 Wenoide，无论对方同不同意。 暂时是 wzeg 的学生。 友链 Push_Y 的博客。 ","link":"https://553032651yyj.github.io/post/brief-introduction/"}]}